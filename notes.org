Haskell Notes

* whitespace matters.  Parallel assignments must start at the same column.
* no statements.  everything is an expression.
* type inference
* all elements of a list must be the same type, but can have any length
* elements of tuples can have any type, but have fixed length
* Most functions are prefix, but not all (i.e., +, - are infix operators)
  * `foo` changes foo from prefix to infix
  * (foo) changes foo from infix to prefix
* There are no parens for calling functions, just
  f x y
  this calls f on x, which returns a new, curried version of f, and that gets called on y
* Function calls bind very tightly, more tightly than arithmetic operators, for example.
  Use parens to control binding.
* Type variables start with lowercase (typically a, b, c,...), Type names start with upper case
* variables and functions must start with lowercase.
* After the first letter, identifiers can contain a lot of different letters, including digits, underscores, and single quotes
* By convention, list variables end with s, lists of lists with ss, etc.
* use -- for comments
* "Overloaded" functions is one where there is a class constraint
  * sum :: Num a => [a] -> a
* Define functions:
  * With equals sign.  Looks a bit mathematical.
    double x = x + x
  * Can also define functions with "guarded equations", no equals sign needed.
    abs n | n >= 0    = n
          | otherwise = -n
  * Pattern matching
    * for example:
      (&&) :: Bool -> Bool -> Bool
      True && True = True
      _ && __ = False
    * But that always evaluates both arguments, so this is better:
      True && b = b
      False && _ = False
    * Patterns are matched in order.
    * cannot repeat variables, like "a && a = a"
    * Lists, instead of [a, b, c] is (a : (b : (c : [])))
* Anonymous functions, lambda expressions.  Use backslash for lambda
  * \x -> x + x
  * odds n = map (\x -> x*2 +1) [0..n-1]
* sections -- partial application of operators
  * 1 + 2
  * (1+) is a function that takes one argument and uses that as the second argument in "1 + _"
  * (+2) is a function that takes one argument and uses that as the first argument in "_ + 2"

* Once you use a name for a type, you can't use it anywhere else
  * does haskell have crappy namespacing?
  * http://stackoverflow.com/questions/4260507/avoiding-namespace-pollution-in-haskell
* list comprehensions
  * The thing that gives the range of values is a "generator"
    [x*x | x <- [1, 2, 3, 4, 5]]
    so the "x <- [1, 2, 3, 4, 5]" part is a generator
  * Order of the generators matters, the first generator moves most slowly, like nested fors
    later generators can use variables from earlier generators
  * filters on a generator are "guards", added after a comma
    factors n = [x | x <- [1..n], n `mod` x == 0]
  * zip
    pairs xs = zip xs (tail xs)
    sorted xs = and [x <= y | (x, y) <- pairs xs]
    positions x xs = [i | (x', i) <- zip xs [0..n], x == x']
      where n = length xs - 1
* ++ is list concatenation
* : is cons
